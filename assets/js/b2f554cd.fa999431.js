"use strict";(self.webpackChunkysfaran_blog=self.webpackChunkysfaran_blog||[]).push([[1477],{10:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/welcome","metadata":{"permalink":"/blog/welcome","source":"@site/blog/welcome.mdx","title":"Welcome","description":"This is Me!","date":"2022-09-05T14:56:30.000Z","formattedDate":"September 5, 2022","tags":[{"label":"welcome","permalink":"/blog/tags/welcome"}],"readingTime":2.61,"hasTruncateMarker":false,"authors":[{"name":"Yusuf Aran","url":"https://avatars.githubusercontent.com/u/13695230","imageURL":"https://avatars.githubusercontent.com/u/13695230","key":"ysfaran"}],"frontMatter":{"title":"Welcome","authors":["ysfaran"],"tags":["welcome"]},"nextItem":{"title":"How to use Playwright with GitHub Actions and GitHub Pages","permalink":"/blog/2022/09/02/playwright-gh-action-gh-pages"}},"content":"## This is Me!\\n\\n:::info TL;DR;\\nI\'m a passionate full-stack developer with strong focus on backend.\\n:::\\n\\nMy journey started in school, where I had my first contact with programming.\\nSince then it was clear that I\'m going to study computer science.\\n\\nAfter I got my bachelor degree I immediately started working at an IT consulting company.\\nAmong programming languages like `C#` and `Python`, I really got to know frontend technologies in depth, especially `React`,\\nand also my beloved `TypeScript`.  \\nSetting up new projects and migrating legacy code helped myself immensely to consolidate my knowledge.\\nSince my drive to write modern software is huge, I immediately jumped on the `React` hooks train.\\nBack then, there really was a lack of libraries supporting form handling with `React` hooks and I also didn\'t like existing solutions at that point in time.\\nSo I took quite some efforts after work to develop my own form library: [react-fluent-form](https://www.react-fluent-form.com/).\\n\\nWhile one part of me loved the new way of `React`, the other part always sought to go more into the direction of backend.\\nIn my next and current working place I started working with technologies like `Vue` quickly moving to setting up a test automation architecture using `Playwright` and finally to `Java` and `AWS` -\\nall on top of a monorepository-microservice project setup.  \\nRegarding `AWS` I was already certified as a Cloud Practitioner in my first company and `Java` was the main programming language in university anyway.\\nWhile I think that `Java` has its own benefits for me, it always felt like that it got into its years at some point (even with newer versions).\\nDon\'t get me wrong, I think `Java` has a great fit in the modern world, especially `Spring Boot`, but it never satisfied me personally.\\n\\nFor this reason, I always write my private projects in `TypeScript` + `Node.js`.\\nIf you utilize the type system of `TypeScript` properly, you are able to work very efficient while being very flexible at any time.\\nPrivately, I also moved from `REST`-like (I purposely say \\"like\\" because almost no one ever implemented REST as it was intended) API\'s to `GraphQL`.  \\nLately I really found myself in the world of cryptocurrencies again, where I also started few private projects.\\nSince I like functional programming concepts a lot, one mainly being immutability, I\'m also planning to get to know `Rust` much better in the future.\\n\\n## About My Blog\\n\\nThe main intention of my blog is to give something back to the great dev community around the globe.\\nBe it Stack Overflow, Discord Channels or GitHub. But of course, this is also some kind of promotion for myself \ud83d\ude04.\\n\\nBy no means my blog posts are deeply researched like you would do it for elaborations in the university.\\nWhat I can guarantee though is, that everything I write down is the best to my knowledge and belief (at that point in time).\\nI never jump to conclusions without taking my time to research properly.\\n\\nIn the end, I hope to help people around the world, by being part and actively contributing to the community. Any constructive criticism is highly appreciated."},{"id":"/2022/09/02/playwright-gh-action-gh-pages","metadata":{"permalink":"/blog/2022/09/02/playwright-gh-action-gh-pages","source":"@site/blog/2022-09-02-playwright-gh-action-gh-pages/index.mdx","title":"How to use Playwright with GitHub Actions and GitHub Pages","description":"playwright + github actions + gh pages","date":"2022-09-05T00:00:00.000Z","formattedDate":"September 5, 2022","tags":[{"label":"playwright","permalink":"/blog/tags/playwright"},{"label":"github","permalink":"/blog/tags/github"},{"label":"github-actions","permalink":"/blog/tags/github-actions"},{"label":"github-pages","permalink":"/blog/tags/github-pages"},{"label":"testing","permalink":"/blog/tags/testing"},{"label":"ci-cd","permalink":"/blog/tags/ci-cd"},{"label":"typescript","permalink":"/blog/tags/typescript"}],"readingTime":10.595,"hasTruncateMarker":false,"authors":[{"name":"Yusuf Aran","url":"https://avatars.githubusercontent.com/u/13695230","imageURL":"https://avatars.githubusercontent.com/u/13695230","key":"ysfaran"}],"frontMatter":{"title":"How to use Playwright with GitHub Actions and GitHub Pages","date":"2022-09-05T00:00:00.000Z","authors":["ysfaran"],"image":"./playwright-gh-actions-gh-pages.png","tags":["playwright","github","github-actions","github-pages","testing","ci-cd","typescript"]},"prevItem":{"title":"Welcome","permalink":"/blog/welcome"},"nextItem":{"title":"useStateWithPromise: a custom hook to await state updates of useState","permalink":"/blog/2020/04/06/await-use-state"}},"content":"![playwright + github actions + gh pages](./playwright-gh-actions-gh-pages.png)\\n\\n## Introduction\\n\\n[Playwright](https://playwright.dev/) is a modern cross-browser testing framework developed by microsoft itself.\\n[GitHub Actions](https://docs.github.com/en/actions/) is the out-of-the-box solution for anything related to CI/CD pipelines on GitHub.\\nLast but not least [GitHub Pages](https://pages.github.com/) is a GitHub feature which allows to deploy static websites.\\n\\nAnd all of this comes completely free for public repositories!\\n\\nIn this blog post I will show you how to setup a basic a Playwright project, integrate it into GitHub Actions and finally deploy an HTML report of the test results to GitHub Pages.\\n\\n:::info\\nThe complete source code can be found in this repo: [ysfaran/playwright-gh-actions-gh-pages](https://github.com/ysfaran/playwright-gh-actions-gh-pages)\\n:::\\n\\nThis post is **not** focusing on explaining all concepts of Playwright, but rather how to connect Playwright, GitHub Actions and GitHub Pages in a easy, non-cost way.\\n\\n## Setup Playwright\\n\\n:::tip\\nFor an up-to-date installation guide please always refer to https://playwright.dev/docs/intro. At the point of writing this posts Playwright\'s latest version was `1.25.1`.\\n:::\\n\\nFortunately Playwright makes it really easy to setup a new project using the CLI:\\n\\n```bash\\nyarn create playwright\\n```\\n\\nThis will start an interactive session. Make sure to at least enable GitHub Action workflow generation. Following is the configuration I used:\\n\\n```bash\\n\u2714 Do you want to use TypeScript or JavaScript? \xb7 TypeScript\\n\u2714 Where to put your end-to-end tests? \xb7 tests\\n\u2714 Add a GitHub Actions workflow? (y/N) \xb7 true\\n```\\n\\n## Generate HTML Report\\n\\nOne of the most important generated files is `playwright.config.ts`, so let\'s have a look at it:\\n\\n:::info\\nI simplified some of the generated files. For a full list of these changes see [`aab0b9c2`](https://github.com/ysfaran/playwright-gh-actions-gh-pages/commit/aab0b9c2f83fb57a31d38af74529062b5198ca45).\\n:::\\n\\n```ts\\nconst config: PlaywrightTestConfig = {\\n  testDir: \\"./tests\\",\\n  // Run all tests within a file in parallel to speed up test execution\\n  fullyParallel: true,\\n  // Helpful for uncontrollable flaky tests, which are tests, occasionally failing for various reasons\\n  retries: 3,\\n  // Generates a HTML report to ./playwright-report/\\n  reporter: \\"html\\",\\n  use: {\\n    // Tests will be run against this page\\n    baseURL: \\"https://playwright.dev/\\",\\n    // Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer\\n    trace: \\"on-first-retry\\",\\n  },\\n  // Cross-browser testing setup\\n  projects: [\\n    {\\n      name: \\"chromium\\",\\n      use: {\\n        ...devices[\\"Desktop Chrome\\"],\\n      },\\n    },\\n    {\\n      name: \\"firefox\\",\\n      use: {\\n        ...devices[\\"Desktop Firefox\\"],\\n      },\\n    },\\n\\n    {\\n      name: \\"webkit\\",\\n      use: {\\n        ...devices[\\"Desktop Safari\\"],\\n      },\\n    },\\n  ],\\n};\\n```\\n\\nSince the `html` reporter is already enabled by default, there are no other adaption necessary.\\nTo get a nice HTML report covering all test result cases (`sucess`, `fail` and `flaky`) following tests have been implemented:\\n\\n```ts\\nimport { test, expect } from \\"@playwright/test\\";\\n\\ntest.beforeEach(({ page }) => page.goto(\\"https://playwright.dev/\\"));\\n\\ntest(\\"should succeed\\", async ({ page }) => {\\n  await expect(page).toHaveTitle(/Playwright/);\\n});\\n\\ntest(\\"should fail\\", async ({ page }) => {\\n  await expect(page).not.toHaveTitle(/Playwright/);\\n});\\n\\ntest(\\"should be flaky\\", async ({ page }) => {\\n  if (Math.random() > 0.5) {\\n    await expect(page).toHaveTitle(/Playwright/);\\n  } else {\\n    await expect(page).not.toHaveTitle(/Playwright/);\\n  }\\n});\\n```\\n\\nTo run the tests execute:\\n\\n```bash\\nnpx playwright test\\n```\\n\\nAfter running all tests Playwright prints a summary of test restuls and publishes the HTML report to a server at a localhost address. Playwright also emits all sources for the HTML report to `playwright-report/`.\\n\\n## Integrate GitHub Actions\\n\\nLuckily Playwright already generated a basic `.github/workflows/playwright.yml` during [Setup Playwright](#setup-playwright) to integrate Playwright tests into a GitHub Actions worklow:\\n\\n```yml\\nname: Playwright Tests\\non:\\n  push:\\n    branches: [main, master]\\njobs:\\n  test:\\n    timeout-minutes: 60\\n    runs-on: ubuntu-latest\\n    steps:\\n      - uses: actions/checkout@v2\\n      - uses: actions/setup-node@v2\\n        with:\\n          node-version: \\"14.x\\"\\n      - name: Install dependencies\\n        run: yarn\\n      - name: Install Playwright Browsers\\n        run: npx playwright install --with-deps\\n      - name: Run Playwright tests\\n        run: yarn playwright test\\n      - uses: actions/upload-artifact@v2\\n        if: always()\\n        with:\\n          name: playwright-report\\n          path: playwright-report/\\n          retention-days: 30\\n```\\n\\nEssentially the workflow is triggered on every `push` and executes the all tests, just like you would do it locally.\\nIt\'s important to note that it also uploads the Playwright HTML report as workflow artifact.\\nThis artifact will be available to download in the `Actions` tab of your GitHub repository in each workflow run.\\n\\nPlease refer to the official Playwright docs on [how to download and view HTML report files](https://playwright.dev/docs/ci-intro#html-report) of a specific workflow run.\\n\\n## Publish HTML Report to GitHub Pages\\n\\nBeing able to download, view and debug HTML reports generate by a CI/CD pipeline locally is already convenient, but there is an easier and faster way to check test results: automatically publish the HTML reports to GitHub Pages and view them directly in the browser.\\n\\nFirstly a new orphan branch, which means the branch has no parent commit, for the GitHub Pages\' static content needs to be created:\\n\\n```bash\\n# Create a new branch without any commit on it\\ngit checkout --orphan gh-pages\\n\\n# Source files get autoamtically staged so remove them from git\\ngit rm -rf .\\n\\n# Optional: Check if there are really no files in the git staging area anymore\\ngit status\\n\\n# Create an initial, empty commit\\ngit commit --allow-empty -m \\"setup empty branch for GitHub Pages\\"\\n\\n# Push the branch to make it available online\\ngit push --set-upstream origin gh-pages\\n```\\n\\nSecondly the GitHub Pages feature needs to be enabled for your repo. Usually GitHub is enabling GitHub Pages automatically when you name a branch `gh-pages`.\\nIf it doesn\'t, make sure to enable GitHub Pages manually in your repository settings:\\n\\n![Enable GitHub Pages](./gh-pages-settings.png)\\n\\nAny change that is pushed to `gh-pages` will now automatically update the GitHub Pages website, which is publicly available at `https://<user>.github.io/<repo>/`.\\nBecause there is no real commit on the `gh-pages` branch yet a 404 error page will be shown.\\n\\nSo the next logical step is to add a new job to the GitHub Actions workflow in order to push the HTML reports to `gh-pages` branch:\\n\\n```yml\\npublish_report:\\n  name: Publish HTML Report\\n  # using always() is not ideal here, because it would also run if the workflow was cancelled\\n  if: \\"success() || needs.test.result == \'failure\'\\"\\n  needs: [test]\\n  runs-on: ubuntu-latest\\n  continue-on-error: true\\n  env:\\n    # Unique URL path for each workflow run attempt\\n    HTML_REPORT_URL_PATH: reports/${{ github.ref_name }}/${{ github.run_id }}/${{ github.run_attempt }}\\n  steps:\\n    - name: Checkout GitHub Pages Branch\\n      uses: actions/checkout@v2\\n      with:\\n        ref: gh-pages\\n    - name: Set Git User\\n      # see: https://github.com/actions/checkout/issues/13#issuecomment-724415212\\n      run: |\\n        git config --global user.name \\"github-actions[bot]\\"\\n        git config --global user.email \\"41898282+github-actions[bot]@users.noreply.github.com\\"\\n    - name: Download zipped HTML report\\n      uses: actions/download-artifact@v2\\n      with:\\n        name: playwright-report\\n        path: ${{ env.HTML_REPORT_URL_PATH }}\\n    - name: Push HTML Report\\n      timeout-minutes: 3\\n      # commit report, then try push-rebase-loop until it\'s able to merge the HTML report to the gh-pages branch\\n      # this is necessary when this job is running at least twice at the same time (e.g. through two pushes at the same time)\\n      run: |\\n        git add .\\n        git commit -m \\"workflow: add HTML report for run-id ${{ github.run_id }} (attempt:  ${{ github.run_attempt }})\\"\\n\\n        while true; do\\n          git pull --rebase\\n          if [ $? -ne 0 ]; then\\n            echo \\"Failed to rebase. Please review manually.\\"\\n            exit 1\\n          fi\\n\\n          git push\\n          if [ $? -eq 0 ]; then\\n            echo \\"Successfully pushed HTML report to repo.\\"\\n            exit 0\\n          fi\\n        done\\n    - name: Output Report URL as Worfklow Annotation\\n      run: |\\n        FULL_HTML_REPORT_URL=https://ysfaran.github.io/playwright-gh-actions-gh-pages/$HTML_REPORT_URL_PATH\\n\\n        echo \\"::notice title=\ud83d\udccb Published Playwright Test Report::$FULL_HTML_REPORT_URL\\"\\n```\\n\\nBasically this job commits the HTML report files to the `gh-pages` branch, which will then automatically redploy the website.\\n\\nIt does so by specifying a new unique path for each test result:\\n\\n```yml\\nHTML_REPORT_URL_PATH: reports/${{ github.ref_name }}/${{ github.run_id }}/${{ github.run_attempt }}\\n```\\n\\nThe job then tries to push these changes and rebases if necessary until a push was succssful.\\nRebasing is safe here, because - as already mentioned - each workflow run gets its own uniquie path, so there can\'t be any file conflicts ever.\\n\\nLast but not least the publicly available URL is printed as GitHub Worfklow Annotation:\\n\\n:::tip\\nIt might take some while for GitHub Pages to update its content after a new push, so the printed URL will point to a 404 page initially.\\nIn the `Actions` tab of your repo you can check `pages-build-deployment` workflow runs, which is automatically triggered for GitHub Pages, to see if the GitHub Pages deployment was successful.\\n:::\\n\\n![URL as GitHub Worfklow Annotation](./workflow-annotation.png)\\n\\n## Add Multi-Branch Support\\n\\nOnly in rare cases you work on a single branch. Also the pipeline is currently not integrated in any pull request process, meaning that there are no restriction to push or even force push to your `main`/`master`.\\nIts time to change that!\\n\\nFirst of all we need to enable branch protections rules for the default branch:\\n\\n1. Go to the settings of your repo\\n2. Select `Branches` under `Code and automation` in the menu\\n3. Hit the `Add branch protection rule` button\\n4. Add your default branchs name for `Branch name pattern`\\n5. Configure your branch protecting rules as desired, most importantly being:\\n\\n![Branch protections rules](./branch-protection-rules.png)\\n\\nNote that I only put `Test` under `Status checks that are required.` because you should still be allowed to merge to `main` branch if some HTML report couldn\'t be published.\\nA green `Test` job for a branch represents a valid state anyway in this case.\\n\\nSecondly the workflow needs to be adapted:\\n\\n```diff\\non:\\n  push:\\n-    branches: [ main, master ]\\n-  pull_request:\\n-    branches: [ main, master ]\\n+    branches-ignore: [ main, gh-pages ]\\n```\\n\\nSo the workflow is triggered after each push on every branch except `main` and `gh-pages`.\\nI purposely removed `pull_request` here, because it\'s really hard (at this point in time) to make `push` and `pull_requests` work together with GitHub Actions.\\nFeel free to check my answer on [StackOverflow answer](https://stackoverflow.com/a/71158335/6489012) regarding this topic.\\n\\n:::caution\\nIf you want to work with `pull_request` every occurence of `${{ github.ref_name }}` should be replaces with `${{ github.head_ref || github.ref_name }}`.\\nCheck the related StackOverflow answer for details: https://stackoverflow.com/a/71158878/6489012.\\n:::\\n\\nI also highly recommend to enable [concurrency groups](https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#concurrency) in your workflow file to make sure only one workflow is running at the same time for each branch:\\n\\n```yaml\\nconcurrency:\\n  group: ${{ github.ref_name }}\\n  # optional\\n  cancel-in-progress: true\\n```\\n\\n## Delete Reports from GitHub Pages\\n\\nAfter a branch was successfully merged it makes sense to delete all corresponding HTML reports from GitHub Pages. This requires the implementation of a new workflow file:\\n\\n```yaml\\nname: Delete\\n\\non:\\n  delete:\\n    branches-ignore: [main, gh-pages]\\n\\n# ensures that currently running Playwright workflow of deleted branch gets cancelled\\nconcurrency:\\n  group: ${{ github.event.ref }}\\n  cancel-in-progress: true\\n\\njobs:\\n  delete_reports:\\n    name: Delete Reports\\n    runs-on: ubuntu-latest\\n    env:\\n      # Contains all reports for deleted branch\\n      BRANCH_REPORTS_DIR: reports/${{ github.event.ref }}\\n    steps:\\n      - name: Checkout GitHub Pages Branch\\n        uses: actions/checkout@v2\\n        with:\\n          ref: gh-pages\\n      - name: Set Git User\\n        # see: https://github.com/actions/checkout/issues/13#issuecomment-724415212\\n        run: |\\n          git config --global user.name \\"github-actions[bot]\\"\\n          git config --global user.email \\"41898282+github-actions[bot]@users.noreply.github.com\\"\\n      - name: Check for workflow reports\\n        run: |\\n          if [ -z \\"$(ls -A $BRANCH_REPORTS_DIR)\\" ]; then\\n            echo \\"BRANCH_REPORTS_EXIST=\\"false\\"\\" >> $GITHUB_ENV\\n          else\\n            echo \\"BRANCH_REPORTS_EXIST=\\"true\\"\\" >> $GITHUB_ENV\\n          fi\\n      - name: Delete reports from repo for branch\\n        if: ${{ env.BRANCH_REPORTS_EXIST == \'true\' }}\\n        timeout-minutes: 3\\n        run: |\\n          cd $BRANCH_REPORTS_DIR/..\\n\\n          rm -rf ${{ github.event.ref }}\\n          git add .\\n          git commit -m \\"workflow: remove all reports for branch ${{ github.event.ref }}\\"\\n\\n          while true; do\\n            git pull --rebase\\n            if [ $? -ne 0 ]; then\\n              echo \\"Failed to rebase. Please review manually.\\"\\n              exit 1\\n            fi\\n\\n            git push\\n            if [ $? -eq 0 ]; then\\n              echo \\"Successfully pushed HTML reports to repo.\\"\\n              exit 0\\n            fi\\n          done\\n```\\n\\nThe job of this workflow is pretty similiar to the one publishing the HTML report. This time it\'s just the other way around: `gh-pages` branch is checked out and the folder `reports/<branch-name>` is deleted.\\nThen the same push-rebase loop is initated to trigger a GitHub Pages deployment.\\n\\nImportant to note here is the following part:\\n\\n:::info\\nThis time the name of the (deleted) branch is neither retreived by `github.head_ref` and `github.ref_name`, but `github.event.ref`.\\nIn case the workflow was triggered by a `delete` the value of `github.ref_name` will be the one of the default branch, here `main`.\\n:::\\n\\n```yaml\\nconcurrency:\\n  group: ${{ github.event.ref }}\\n  cancel-in-progress: true\\n```\\n\\nThis statement makes sure that any running workflow within the same concurrency group will be cancelled.\\nIn our case this means if tests for a deleted branch are still running, they will be cancelled.\\n\\n## Conclusion\\n\\nWe created a Playwright project from scratch, integrated tests in GitHub Actions, deployed test results to GitHub Pages and finally established branch protections rules with a simple but important pull request strategy.\\nAll of this, without any costs.\\n\\nAll in all it\'s all about automation and process optimization. Keeping a team busy with daunting manual tasks can decrease effincy and motivation quite a bit.\\nThis can go from manual deployment plans to smaller aspects like hard to debug test results. In the long run saving some minutes of daily, manual work can have a huge impact.\\n\\nFeel free to use one of the Contact options in the footer in case of questions or feedback. \ud83d\ude42"},{"id":"/2020/04/06/await-use-state","metadata":{"permalink":"/blog/2020/04/06/await-use-state","source":"@site/blog/2020-04-06-await-use-state/index.mdx","title":"useStateWithPromise: a custom hook to await state updates of useState","description":"await useState illustration","date":"2020-04-06T00:00:00.000Z","formattedDate":"April 6, 2020","tags":[{"label":"react","permalink":"/blog/tags/react"},{"label":"webdev","permalink":"/blog/tags/webdev"},{"label":"react-hooks","permalink":"/blog/tags/react-hooks"},{"label":"typescript","permalink":"/blog/tags/typescript"}],"readingTime":8.175,"hasTruncateMarker":false,"authors":[{"name":"Yusuf Aran","url":"https://avatars.githubusercontent.com/u/13695230","imageURL":"https://avatars.githubusercontent.com/u/13695230","key":"ysfaran"}],"frontMatter":{"title":"useStateWithPromise: a custom hook to await state updates of useState","date":"2020-04-06T00:00:00.000Z","authors":["ysfaran"],"image":"./await-use-state.png","tags":["react","webdev","react-hooks","typescript"]},"prevItem":{"title":"How to use Playwright with GitHub Actions and GitHub Pages","permalink":"/blog/2022/09/02/playwright-gh-action-gh-pages"},"nextItem":{"title":"react-fluent-form: How to write forms with validation in few steps","permalink":"/blog/2020/03/26/react-fluent-form"}},"content":"![await useState illustration](./await-use-state.png)\\n\\n## The Problem\\n\\nThe general problem is that we want to wait for a state update an then do something afterwards. Unfortunatly we can not write sequential code, because every state update is asynchronous.\\nIn \\"old\\" react we could simply pass a callback. As an example we will look at a class component, that contains filters for an article list view:\\n\\n```jsx\\nclass FilterSidebar extends React.Component {\\n  constructor() {\\n    this.state = {\\n      filters: {},\\n      articles: [],\\n    };\\n  }\\n\\n  fetchArticles = async () => {\\n    const fetchedArticles = await API.getArticles(this.state.filters);\\n    this.setState({ articles: fetchedArticles });\\n  };\\n\\n  reset = () => {\\n    this.setState({ filters: {} }, this.fetchArticles);\\n  };\\n\\n  setColorFilter = (color) => {\\n    this.setState((state) => ({ filters: { ...state.filters, color } }));\\n  };\\n\\n  // more filters & render ...\\n}\\n```\\n\\n- `fetchArticles`: fetch `articles` from an API service based on the `filters` in the state.\\n- `reset`: clear all `filters` and then fetch `articles`, by passing `fetchArticles` as callback to `setState`. This will guarantee that the state of `filters` is cleared before calling `fetchArticles`\\n- `setColorFilter`: sets filter for `articles` to have a specific color (just an example to help your imagination!)\\n\\nUsing functional components this would look a bit different:\\n\\n```jsx\\nconst FiltersSidebar = () => {\\n  const [articles, setArticles] = useState([]);\\n  const [filters, setFilters] = useState({});\\n\\n  const fetchArticles = async () => {\\n    const fetchedArticles = await API.getArticles(filters);\\n    setArticles(fetchedArticles);\\n  };\\n\\n  const reset = () => {\\n    setFilters({});\\n\\n    // uuhh, ouhh .. fetchArticles will use old state of \\"filters\\"\\n    fetchArticles();\\n  };\\n\\n  const setColorFilter = (color) => {\\n    setFilters((currentFilters) => ({ ...currentFilters, color }));\\n  };\\n\\n  // more filters & return ..\\n};\\n```\\n\\nThe problem here is that the setter, which is returned by `useState` (here `setFilters`), doesn\'t allow us to pass a callback function as second argument. But in this case we can use `useEffect` and `useRef` to handle the problem:\\n\\n```jsx\\nconst FiltersSidebar = () => {\\n  const [articles, setArticles] = useState([]);\\n  const [filters, setFilters] = useState({});\\n  const resettingRef = useRef(false);\\n\\n  const fetchArticles = async () => {\\n    const fetchedArticles = await API.getArticles(filters);\\n    setArticles(fetchedArticles);\\n  };\\n\\n  const reset = () => {\\n    resettingRef.current = true;\\n    setFilters({});\\n  };\\n\\n  useEffect(() => {\\n    if (resettingRef.current) {\\n      resettingRef.current = false;\\n      fetchArticles();\\n    }\\n  }, [filters]);\\n\\n  // ...\\n};\\n```\\n\\nOkay, that looks a bit ugly but at least it works..\\nBut what happens if the filter logic gets much more complicated and we want to extract logic for filters in custom hooks:\\n\\n```jsx\\nconst useStringFilter = (initialValue = \\"\\") => {\\n  const [value, setValue] = useState(initialValue);\\n\\n  // maybe more complex stuff here\\n\\n  const reset = () => {\\n    setValue(initialValue);\\n  };\\n\\n  return {\\n    value,\\n    setValue,\\n    reset,\\n  };\\n};\\n\\n// and filters for other types like useDateFilter etc..\\n```\\n\\nThen our component could look like this:\\n\\n```jsx\\nconst FiltersSidebar = () => {\\n  const [articles, setArticles] = useState([]);\\n\\n  const colorFilter = useStringFilter();\\n  const nameFilter = useStringFilter();\\n  const releaseDateFilter = useDateFilter();\\n\\n  const fetchArticles = async () => {\\n    const filters = {\\n      color: colorFilter.value,\\n      name: nameFilter.value,\\n      releaseDate: releaseDateFilter.value,\\n    };\\n    const fetchedArticles = await API.getArticles(filters);\\n    setArticles(fetchedArticles);\\n  };\\n\\n  const reset = () => {\\n    colorFilter.reset(); // will trigger a state update inside of useStringFilter\\n    nameFilter.reset(); // will trigger a state update inside of useStringFilter\\n    releaseDateFilter.reset(); // will trigger a state update inside of useDateFilter\\n\\n    // fetchArticles will use old state of colorFilter, nameFilter and releaseDateFilter\\n    fetchArticles();\\n  };\\n\\n  // ...\\n};\\n```\\n\\n**_What to do now?_**  \\nThere is no straightforward way when using `useEffect` and `useRef` anymore, because we need to wait for multiple state updates to be completed. And that exactly is the actual problem!\\n\\n## The Solution\\n\\nWith a custom hook - namely `useStateWithPromise` - this problem can be solved:\\n\\n```jsx\\nconst useStateWithPromise = (initialState) => {\\n  const [state, setState] = useState(initialState);\\n  const resolverRef = useRef(null);\\n\\n  useEffect(() => {\\n    if (resolverRef.current) {\\n      resolverRef.current(state);\\n      resolverRef.current = null;\\n    }\\n    /**\\n     * Since a state update could be triggered with the exact same state again,\\n     * it\'s not enough to specify state as the only dependency of this useEffect.\\n     * That\'s why resolverRef.current is also a dependency, because it will guarantee,\\n     * that handleSetState was called in previous render\\n     */\\n  }, [resolverRef.current, state]);\\n\\n  const handleSetState = useCallback(\\n    (stateAction) => {\\n      setState(stateAction);\\n      return new Promise((resolve) => {\\n        resolverRef.current = resolve;\\n      });\\n    },\\n    [setState]\\n  );\\n\\n  return [state, handleSetState];\\n};\\n```\\n\\nIt\'s not important to fully understand this hook. But what you should understand is that `useStateWithPromise` returns, just like `useState`, a getter and setter with a small important difference:  \\n**the setter returns a `Promise`, which we can `await`!**\\n\\nNow we can replace the `useState` statements in our custom filter hooks with `useStateWithPromise`:\\n\\n```jsx\\nconst useStringFilter = (initialValue = \\"\\") => {\\n  const [value, setValue] = useStateWithPromise(initialValue);\\n\\n  const reset = () => {\\n    // this will return a promise containing the updated state\\n    return setValue(initialValue);\\n  };\\n\\n  return {\\n    value,\\n    setValue,\\n    reset,\\n  };\\n};\\n```\\n\\nAnd then we can finally `await` state updates:\\n\\n```jsx\\nconst FiltersSidebar = () => {\\n  // ...\\n\\n  const reset = async () => {\\n    // wait for all state updates to be completed\\n    await Promise.all([\\n      colorFilter.reset(),\\n      nameFilter.reset(),\\n      releaseDateFilter.reset(),\\n    ]);\\n\\n    // fetchArticles will STILL use old state of colorFilter, nameFilter and releaseDateFilter\\n    fetchArticles();\\n  };\\n\\n  // ...\\n};\\n```\\n\\nWell, that was a WT.. moment for me, but it makes sense if you really think about how functional components work.\\n\\nViewing the code from plain JavaScript side (without react) **`reset` is just a function inside of a function(al component)**. So each time the function is called (in the react terms: the functions is **rerendered**), **`reset` will be a new function with a new reference**. After we `await` the state updates of the filters with `Promise.all`, `reset` will still point to the exact same \\"old\\" `fetchArticles` reference, **which is still pointing to \\"old\\" state**! But in the meantime multiple state updates happend and there is much \\"newer\\" version of `reset` and also `fetchArticles`, **which is pointing to the updated state**.\\n\\n{% asset_img rerendered-functions.png  rerendered functions example %}\\n\\nWith one additional state property, here `resetted`, this can be fixed:\\n\\n```jsx\\nconst FiltersSidebar = () => {\\n  // ...\\n  const [resetted, setResetted] = useState(false);\\n\\n  useEffect(() => {\\n    if (resetted) {\\n      fetchArticles();\\n      setResetted(false);\\n    }\\n  }, [resetted]);\\n\\n  const reset = async () => {\\n    await Promise.all([\\n      colorFilter.reset(),\\n      nameFilter.reset(),\\n      releaseDateFilter.reset(),\\n    ]);\\n\\n    setResetted(true);\\n  };\\n\\n  // ...\\n};\\n```\\n\\nNow `setResetted(true)` will trigger a rerender of the component and it\'s guaranteed that the `fetchArticles` call inside of the `useEffect` statement will use the latest state for the API call.\\n\\n## The Solution ?\\n\\nWhen I implemented `useStateWithPromise` I really thought that\'s the perfect solution and also questioned why there is no build-in solution for this in react? But after my WT.. moment I really understood why react didn\'t include such functionality:\\n\\n**It simply doesn\'t fit to the general design of functional components!**\\n\\nWhen you use class components, you work a lot with mutable references (e.g. `this.state` is reference that constantly gets updated by `this.setState` calls). But that\'s an anti pattern for functional components, because here you always try to work with immutable data and there is a reason for that:\\n\\n**Mutable references tend to cause unwanted side effects!**\\n\\nIf your state has a non-primitive type (e.g. an object or array) it\'s recommended create new references instead of keeping the old one:\\n\\n```jsx\\nconst MyComponent = () => {\\n  const [immutableData, setImmutableData] = useState({ a: \\"a\\", b: \\"b\\" });\\n  let [mutableData, setMutableData] = useState({ a: \\"a\\", b: \\"b\\" });\\n\\n  const setNewData = () => {\\n    // good: new reference!\\n    setImmutableData({ a: \\"new a\\", b: \\"new b\\" });\\n\\n    // bad: same reference!\\n    mutableData.a = \\"new a\\";\\n    mutableData.b = \\"new b\\";\\n    setMutableData(mutableData);\\n  };\\n\\n  useEffect(() => {\\n    console.log(\\"immutable data changed\\");\\n  }, [immutableData]);\\n\\n  // will never be called because mutableData will always have same reference\\n  useEffect(() => {\\n    console.log(\\"mutable data changed\\");\\n  }, [mutableData]);\\n\\n  return (\\n    <>\\n      <ChildComponent data={immutableData} />\\n      {/**\\n       * changing mutableData without the state setter, (e.g. mutableData.a = \\"new a\\")\\n       * could cause unwanted side effects, because ChildComponent wouldn\'t be rerendered,\\n       * so e.g. no useEffect statements inside ChildComponent would be triggered\\n       */}\\n      <ChildComponent data={mutableData} />\\n    </>\\n  );\\n};\\n```\\n\\nTo come back to the example:\\n\\n- each state update (e.g. `reset` of filter) causes a rerender\\n- each rerender creates a new reference for `reset` and `fetchArticles`\\n- each `fetchArticles` reference will point to a different immutable state\\n- after the `await` in `reset` the `fetchArticles` call will use \\"old\\" state, because it\'s an \\"old\\" version of `fetchArticles`\\n\\nSo the general issue is that we have multiple `fetchArticles` versions (after each render) which all point to different states, because states in functional components are/should be immutable.\\n\\n## Conclusion\\n\\nThere is a reason why react didn\'t implement this feature for functional components. If you have the time and the ability to (re-)build the architecture of your app, you should really think about using `useStateWithPromise`.\\n\\nI used it once in production, but only because the time was limited and my customer didn\'t want to spent to much time refactoring the code. For the next project I had a similiar problem but was able to switch the approach and solve this problem differently. E.g. in our example the actual problem was that we had multiple states in multiple hooks but could not reset them easily all at once (we needed to call `reset` on each filter). If the state of all filters would be in one place, it would be much easier to reset them all together. A different approach would be to store inital values in a ref so you it\'s not even necessary to wait for the state to be updated.\\n\\nAs final conclusion: If you have the necessarity to `await` state updates in a manner like with `useStateWithPromise` you either have a non-ideal architechture, your requirments have changed or you have a really special case. \ud83d\ude09"},{"id":"/2020/03/26/react-fluent-form","metadata":{"permalink":"/blog/2020/03/26/react-fluent-form","source":"@site/blog/2020-03-26-react-fluent-form/index.mdx","title":"react-fluent-form: How to write forms with validation in few steps","description":"react-fluent-form logo","date":"2020-03-26T00:00:00.000Z","formattedDate":"March 26, 2020","tags":[{"label":"react","permalink":"/blog/tags/react"},{"label":"webdev","permalink":"/blog/tags/webdev"},{"label":"react-hooks","permalink":"/blog/tags/react-hooks"},{"label":"forms","permalink":"/blog/tags/forms"},{"label":"typescript","permalink":"/blog/tags/typescript"}],"readingTime":12,"hasTruncateMarker":false,"authors":[{"name":"Yusuf Aran","url":"https://avatars.githubusercontent.com/u/13695230","imageURL":"https://avatars.githubusercontent.com/u/13695230","key":"ysfaran"}],"frontMatter":{"title":"react-fluent-form: How to write forms with validation in few steps","date":"2020-03-26T00:00:00.000Z","authors":["ysfaran"],"image":"./react-fluent-form-logo.svg","tags":["react","webdev","react-hooks","forms","typescript"]},"prevItem":{"title":"useStateWithPromise: a custom hook to await state updates of useState","permalink":"/blog/2020/04/06/await-use-state"}},"content":"![react-fluent-form logo](./react-fluent-form-logo.svg)\\n\\n## Background\\n\\nMaybe you know how complicated react state handling for forms - including validation - can be and you already researched for a library that fits to your use case. To make things more complicated we often implement **custom fields** or use third party libraries like [react-select](https://www.npmjs.com/package/react-select).\\n\\nI was not satisfied (at least not 100%) with any solution on npm so I developed a form library myself:\\n\\n[![ysfaran/react-fluent-form - GitHub](https://gh-card.dev/repos/ysfaran/react-fluent-form.svg)](https://github.com/ysfaran/react-fluent-form)\\n\\n**_Why are you not satisfied with existing solutions?_**\\n\\n:::caution DISCLAIMER\\n\\nOf course every library has its up- and downsides (also mine..) and there are for sure great form libraries out there! But I just want to highlight the topics that annoyed me personally.\\n\\n:::\\n\\n- The libraries I found and also used in some of my projects were **not intuitive** enough. I\'m a simple guy who wants a simple API!\\n- Some libraries came with a lot of **boilerplate code**.\\n- I used **a lot of custom fields** and all libraries forced me to something I didn\'t like (e.g. wrap my custom field in another component) or didn\'t support customization in the level I would like it.\\n- Many libraries had **no easy-to-use validation** approach.\\n- **Missing features** like form arrays.\\n\\n**_Why is react-fluent-form satisfying your needs?_**\\n\\n- It (hopefully) provides a **more intuitive fluent API**.\\n- It comes with a **easy-to-use validation** approach using [yup](https://www.npmjs.com/package/yup) schemes. If you don\'t like `yup`, you can also write your **custom validator**!\\n- Customization is made fairly easy, because you can add as many **reusable custom fields** as required, **without touching any component**.\\n- It **reduces boilerplate code** by enabling a simple API.\\n\\n## Stop talking. Let\'s code!\\n\\nTalking is good, showing is better! The next section will go step by step through the creation proccess of a form using `react-fluent-form`.\\n\\n### 1. Configuring the form\\n\\nThe heart of `react-fluent-form` is the form config since it\'s the part of it that actually provides the _fluent_ API:\\n\\n:::info NOTE\\nAll code snippets will be in typescript, because the library is also written in typescript!\\n:::\\n\\n```ts\\nimport * as yup from \\"yup\\";\\nimport { createForm, field } from \\"react-fluent-form\\";\\n\\ninterface RegistrationForm {\\n  username: string;\\n  password: string;\\n}\\n\\nconst formConfig = createForm<RegistrationForm>()({\\n  username: field.text(\\"user0\\"),\\n  password: field.password().validateOnSubmitOnly(),\\n}).withValidation({\\n  username: yup.string().required().min(4),\\n  password: yup.string().required().min(8),\\n});\\n```\\n\\n**STOP! Try to understand the code without ever seeing it before!**\\n\\nOkay, so we just specified how our registration form will look like:\\n\\n- It will have two input fields: Username and Password\\n  - Username will have the default value `user0`\\n  - Password will be an empty string\\n  - It will also trigger validation for Password only when a submit has been initiated. There are more validation triggers available but the default is `validateAfterTouchOnChange`, which means once the field lost focus it will be validated after each change.\\n  - `field.text()` and `field.password()` actually represent the options for the `type` property of the HTML input element\\n- We added validation for each field using `yup` schemes. Those schemes perfectly fit into `react-fluent-form` since `yup` also provides a _fluent_ API!\\n  - Username is a required string and must have at least length of 4 characters\\n  - Password is required string and must have at least length of 8 characters\\n\\n### 2. Initializing the form\\n\\nCool, we configured our form but that was just plain typescript, no react involved. `react-fluent-form` comes with a set of react hooks, but the most important one is `useFluentForm`:\\n\\n```jsx\\nconst RegistrationForm = () => {\\n  // We just used the config we created before and that\'s all we need!\\n  const { values, touched, validity, errors /* and more */ } =\\n    useFluentForm(formConfig);\\n\\n  // ...\\n};\\n```\\n\\nAmong other things `useFluentForm` returns:\\n\\n- **`values`**: it\'s an object that contains the current values entered to the form. In this example it would look like `{username: \\"user0\\", password: \\"\\"}` in the beginning.\\n- **`touched`**: it\'s an object that stores information about the touched state of each field. A field is _touched_ once it had focus and then lost it, so from a technical perspective if the `onBlur` event of an input field was triggert. An example object could be `{username: true, password: undefined}` (`undefined` means it was not touched yet).\\n- **`validity`**: it\'s an object that stores information about the validation state of each field. It could look like `{username: false, password: undefined}` (`undefined` means it was not validated yet).\\n- **`errors`**: it\'s an object that contains the current errors of each field in the form. In case of an error the evaluation of `yup` schemes will result in a `string[]` type, so the errors object could look like `{username: [\\"username is a required field\\"], password: undefined }` (`undefined` means the field was not validated yet or that it\'s valid).\\n\\n### 3. Rendering the form\\n\\nWe set up all logic, let\'s start rendering our form now:\\n\\n```jsx\\nfunction RegistrationForm() {\\n  const { values, fields, errors, handleSubmit } = useFluentForm(formConfig);\\n\\n  const handleSubmitSuccess = () => console.log(values);\\n\\n  const handleSubmitFailure = () => console.log(errors);\\n\\n  return (\\n    <form onSubmit={handleSubmit(handleSubmitSuccess, handleSubmitFailure)}>\\n      <label>\\n        Username*:\\n        <input {...fields.username} />\\n      </label>\\n      <label>\\n        Password*:\\n        <input {...fields.password} />\\n      </label>\\n      <button type=\\"submit\\">Submit</button>\\n    </form>\\n  );\\n}\\n```\\n\\nAnd that\'s it! But wait we have two new properties here:\\n\\n- **`fields`**: is an object that contains the props for the to render component. As you might remember `react-fluent-form` exports a `field` variable that allowed us to specify the type of the input field (e.g. `field.password()`). It supports every reasonable HTML input type like checkboxes or radio buttons and also the HTML elements `textarea` and `select`. So in our example `fields` would have following type:\\n\\n```ts\\n{\\n  username: {\\n    type: \\"text\\";\\n    value: string;\\n    onChange: (e: ChangeEvent<HTMLInputElement>) => void;\\n    onBlur: () => void;\\n  },\\n  password: {\\n    type: \\"password\\";\\n    value: string;\\n    onChange: (e: ChangeEvent<HTMLInputElement>) => void;\\n    onBlur: () => void;\\n  },\\n}\\n```\\n\\n- **`handleSubmit`**: is a function that returns a callback for the form submission. Optionally it allows us to pass a `success` and `failure` callback, which are called dependent on the validation result of the whole form. If at least one field is invalid, `failure` will be called, otherwise `success`.\\n\\n### 4. Displaying feedback messages\\n\\nThis is actually not mandatory but it surly improves UX! For simple error displays you can just add a check on the errors object and display it if there is one:\\n\\n```jsx\\nconst RegistrationForm = () => {\\n  //...\\n\\n  return (\\n    <form onSubmit={handleSubmit(handleSubmitSuccess, handleSubmitFailure)}>\\n      <label>\\n        Username*:\\n        <input {...fields.username} />\\n        {errors.username && <div> {errors.username[0]} </div>}\\n      </label>\\n      <label>\\n        Password*:\\n        <input {...fields.password} />\\n        {errors.password && <div> {errors.password[0]} </div>}\\n      </label>\\n      <button type=\\"submit\\">Submit</button>\\n    </form>\\n  );\\n};\\n```\\n\\nIf the feedback process is more complex (e.g. you want to show if a field is valid, not just if it\'s invalid) you can take advantage of information stored in `validity` and `touched`.\\nI\'m sure you will find a good solution for your needs!\\n\\n## Customization\\n\\nSo we talked a lot about a very simple form, but **until here I would just hate my own library**. _Why?_ Because every project is different and every application has different requirements. It\'s cool and very useful that standard HTML elements are supported, but when did you use a standard HTML `select` element or an standard HTML datepicker the last time? I mean they are very hard to customize (sometimes it\'s not even possible) and they don\'t support features mandatory for professional UX.\\n\\nOkay, I calmed down. Let\'s focus on the code again!\\n\\n### Customizing fields\\n\\nFor simple components like [`react-datepicker`](https://www.npmjs.com/package/react-datepicker) `react-fluent-form` provides `field.raw()`.\\n\\n**_What means simple component in this context?_**\\n\\n- it has `value`-like and a `onChange`-like prop\\n- `value` has the same type as the first parameter of `onChange` handler\\n- it optionally has a `onBlur`-like prop to indicate when the field is touched\\n\\n\\\\*-like means it must not have the same name, but the same type. E.g. the `value` prop in `react-datepicker` is called `selected`.  \\nFor raw fields it\'s required to pass an initial value, otherwise it will be undefined:\\n\\n```jsx\\ntype DateValue = Date | null;\\n\\nconst formConfig = createForm()({\\n  dateOfBirth: field.raw < DateValue > null.withValueProp(\\"selected\\"),\\n});\\n```\\n\\nThe type of `fields` object would look like this:\\n\\n```ts\\ntype FieldsType = {\\n  dateOfBirth: {\\n    selected: Date | null;\\n    onChange: (newValue: Date | null) => void;\\n    onBlur: () => void; // will just set the \\"touched\\" state to true\\n  };\\n};\\n```\\n\\nOn default `field.raw` will be mapped to properties `value`, `onChange` and `onBlur`. Names of these properties can easily be changed using `withValueProp` (as in the example), `withOnChangeProp` and `withOnBlurProp`.\\nBut, oh boy, I would not like to write\\n\\n```ts\\nfield.raw<DateValue>(null).withValueProp(\\"selected\\");\\n```\\n\\neach time I need a datepicker.\\n\\nA simple approach is to wrap it in a function:\\n\\n```ts\\nconst datePicker = (initialValue: DateValue = null) => {\\n  return field.raw<DateValue>(initialValue).withValueProp(\\"selected\\");\\n};\\n\\nconst formConfig = createForm()({\\n  dateOfBirth: datePicker(),\\n});\\n```\\n\\nBut to me that looks kind of odd if put next to other fields:\\n\\n```ts\\nconst formConfig = createForm<RegistrationForm>()({\\n  username: field.text(\\"user0\\"),\\n  dateOfBirth: datePicker(),\\n  password: field.password().validateOnSubmitOnly(),\\n});\\n```\\n\\nIdeally I would like to have `field.datePicker()` so it fits perfectly to the rest of the library. For this purpose `react-fluent-form` exports a utility function `addField`:\\n\\n```ts\\nimport { addField, RawField, field } from \\"react-fluent-form\\";\\n\\naddField(\\"datePicker\\", (initialValue: DateValue = null) =>\\n  field.raw(initialValue).withValueProp(\\"selected\\")\\n);\\n```\\n\\nand then you can just use `field.datePicker()` anywhere you want!\\n\\nBut wait, there are few things to note down here:\\n\\n- `addField` needs to be called in a top level file, which means `addField` statements need to be executed before e.g. `field.datePicker()` is used somewhere.\\n- For Typescript users (like me) this gets a bit more complicated. Typescript will not know about `field.datePicker()` until we tell the compiler about it. Since types always need to be known at compile time, this part can\'t be handled by the library itself.\\n\\n```ts\\nimport { RawField } from \\"react-fluent-form\\";\\n\\ndeclare module \\"react-fluent-form\\" {\\n  interface FieldCreator {\\n    datePicker: (initialValue?: DateValue) => RawField<DateValue, \\"selected\\">;\\n    // add more custom fields here\\n  }\\n}\\n```\\n\\nFor customization of configurable/complex fields please have a look at [official `react-fluent-form` docs](https://www.react-fluent-form.com/docs/getting-started/customization/#adding-custom-fields).\\n\\n### Customizing validation\\n\\nEqually to form state handling, form validation handling is really important topic on modern websites. So it\'s important to have a flexible and easy to use validation approach.\\n\\nThat\'s why `react-fluent-form` makes validation customizable.\\nInstead of a `yup` schema you can also provide a function which receives:\\n\\n- the current `value` of the to validate field\\n- the current `values` of the form\\n- the `context` object (we will see what that means later)\\n\\nIf the validate function returns **anything** beside of `undefined` the validated field will be marked as invalid. Also the return value will be the error:\\n\\n```ts\\nconst formConfig = createForm<RegistrationForm>()({\\n  username: field.text(\\"user0\\"),\\n  dateOfBirth: field.datePicker(),\\n  password: field.password().validateOnSubmitOnly(),\\n}).withValidation({\\n  // ...\\n  password: (value, values, context) => {\\n    if (!value) return \\"password is mandatory\\";\\n    if (!value.length < 8) return \\"password must be 8 characters long\\";\\n  },\\n});\\n```\\n\\nWe could possibly return very complex objects here to add more details to the error itself (and it will be typesafe!).\\n\\nIf we return a `yup` schema though, it will be a special case:\\n\\n```ts\\nconst formConfig = createForm<RegistrationForm>()({\\n  username: field.text(\\"user0\\"),\\n  dateOfBirth: field.datePicker(),\\n  password: field.password().validateOnSubmitOnly(),\\n}).withValidation({\\n  // ...\\n  // we just destructured username from values object so it looks a bit cleaner!\\n  password: (value, { username }, context) => {\\n    if (username && value.includes(username)) {\\n      /**\\n       * It\'s an array since yup schema below will\\n       * also result in a error of type string[]\\n       * So it\'s easier to handle errors\\n       * if they all have the same type\\n       */\\n      return [\\"password can\'t contain username\\"];\\n    } else {\\n      return yup.string().required().min(8);\\n    }\\n  },\\n});\\n```\\n\\nI think you already know what\'s happening here. When we return a `yup` schema in a validate function it will not be treated as the error type, it will evaluate the the schema instead, so the error type will be `string[]`. And we actually just implemented **conditional validation**! Password is now validated based on the username field.\\n\\nBut whats about fields outside of the form? That\'s exactly why we have **validation context**. The initial context can be set via config while you can adapt the context at any time with `setContext` returned by `useFluentForm`.\\nThe validation context needs to be **any object**, so it can not be a plain number or a string.\\n\\nLet\'s assume that we have a country select which is outside of our registration form. The current country will be passed to the `RegistrationForm` component via props. Dependent on the selected country the minimum age for the `Date of Birth` field will vary (for USA 16, for the rest 18):\\n\\n```jsx\\ninterface RegistrationFormProps {\\n  country: string;\\n}\\n\\nconst formConfig = createForm<RegistrationForm>()({\\n  /* fields.. */}\\n).withContext({\\n  country: \\"USA\\",\\n})\\n\\nconst RegistrationForm: React.FC<RegistrationFormProps> = ({country}) => {\\n  const { setContext } = useFluentForm(formConfig);\\n\\n  useEffect(() => setContext({ country }), [country]);\\n\\n  //...\\n}\\n```\\n\\nAs we can see it\'s pretty easy to update the context when it changes with `useEffect`. Now we can implement conditional validation based on the current context value:\\n\\n```ts\\n// using validate function\\nformConfing.withValidation({\\n  dateOfBirth: (value, values, { country }) => {\\n    if (country === \\"USA\\") {\\n      return yup.date().required().max(yearsBack16, \\"you must be at least 16\\");\\n    } else {\\n      return yup.date().required().max(yearsBack18, \\"you must be at least 18\\");\\n    }\\n  },\\n});\\n\\n// using yup\\nformConfing.withValidation({\\n  dateOfBirth: yup.date().when(\\"$country\\", {\\n    is: \\"USA\\",\\n    then: yup.date().required().max(yearsBack16, \\"you must be at least 16\\"),\\n    otherwise: yup\\n      .date()\\n      .required()\\n      .max(yearsBack18, \\"you must be at least 18\\"),\\n  }),\\n});\\n```\\n\\nFor customization of the validator please have a look at [official `react-fluent-form` docs](https://www.react-fluent-form.com/docs/getting-started/customization/#adding-custom-validator).\\n\\n## Play around and see how it works!\\n\\nFollowing code sandbox contains the implementation of the previous examples in typescript! Just check it out:\\n\\n<iframe\\n  src=\\"https://codesandbox.io/embed/practical-hertz-pgcxl?fontsize=14&hidenavigation=1&theme=dark\\"\\n  style={{\\n    width: \\"100%\\",\\n    height: \\"500px\\",\\n    border: \\"0\\",\\n    borderRadius: \\"4px\\",\\n    overflow: \\"hidden\\",\\n  }}\\n  title=\\"practical-hertz-pgcxl\\"\\n  allow=\\"geolocation; microphone; camera; midi; vr; accelerometer; gyroscope; payment; ambient-light-sensor; encrypted-media; usb\\"\\n  sandbox=\\"allow-modals allow-forms allow-popups allow-scripts allow-same-origin\\"\\n></iframe>\\n\\nIf you are not clear with something or you want to know about other features like **form arrays** just checkout the [official `react-fluent-form` docs](https://www.react-fluent-form.com/)\\n\\n## Conclusion\\n\\nThere a lot of form libraries out there and I simply tried to put all the good approached I observed so far in one library. You saw the things through my eyes and I\'m sure you will totally agree on some points, but also totally disagree on others. And that\'s okay! I\'m always open for constructive feedback, so feel free to [file an issue or improvement on GitHub](https://github.com/ysfaran/react-fluent-form/issues)!\\n\\n**Every contribution is welcome!**"}]}')}}]);