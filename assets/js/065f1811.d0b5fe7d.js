"use strict";(self.webpackChunkysfaran_blog=self.webpackChunkysfaran_blog||[]).push([[2400],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>g});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=p(n),g=r,m=c["".concat(l,".").concat(g)]||c[g]||h[g]||i;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function g(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},6353:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var a=n(7462),r=(n(7294),n(3905));const i={title:"How to use Playwright with GitHub Actions and GitHub Pages",date:new Date("2022-09-05T00:00:00.000Z"),authors:["ysfaran"],image:"./playwright-gh-actions-gh-pages.png",tags:["playwright","github","github-actions","github-pages","testing","ci-cd","typescript"]},o=void 0,s={permalink:"/blog/2022/09/02/playwright-gh-action-gh-pages",source:"@site/blog/2022-09-02-playwright-gh-action-gh-pages/index.mdx",title:"How to use Playwright with GitHub Actions and GitHub Pages",description:"playwright + github actions + gh pages",date:"2022-09-05T00:00:00.000Z",formattedDate:"September 5, 2022",tags:[{label:"playwright",permalink:"/blog/tags/playwright"},{label:"github",permalink:"/blog/tags/github"},{label:"github-actions",permalink:"/blog/tags/github-actions"},{label:"github-pages",permalink:"/blog/tags/github-pages"},{label:"testing",permalink:"/blog/tags/testing"},{label:"ci-cd",permalink:"/blog/tags/ci-cd"},{label:"typescript",permalink:"/blog/tags/typescript"}],readingTime:10.535,hasTruncateMarker:!1,authors:[{name:"Yusuf Aran",url:"https://avatars.githubusercontent.com/u/13695230",imageURL:"https://avatars.githubusercontent.com/u/13695230",key:"ysfaran"}],frontMatter:{title:"How to use Playwright with GitHub Actions and GitHub Pages",date:"2022-09-05T00:00:00.000Z",authors:["ysfaran"],image:"./playwright-gh-actions-gh-pages.png",tags:["playwright","github","github-actions","github-pages","testing","ci-cd","typescript"]},prevItem:{title:"Welcome",permalink:"/blog/welcome"},nextItem:{title:"useStateWithPromise: a custom hook to await state updates of useState",permalink:"/blog/2020/04/06/await-use-state"}},l={image:n(9720).Z,authorsImageUrls:[void 0]},p=[{value:"Introduction",id:"introduction",level:2},{value:"Setup Playwright",id:"setup-playwright",level:2},{value:"Generate HTML Report",id:"generate-html-report",level:2},{value:"Integrate GitHub Actions",id:"integrate-github-actions",level:2},{value:"Publish HTML Report to GitHub Pages",id:"publish-html-report-to-github-pages",level:2},{value:"Add Multi-Branch Support",id:"add-multi-branch-support",level:2},{value:"Delete Reports from GitHub Pages",id:"delete-reports-from-github-pages",level:2},{value:"Conclusion",id:"conclusion",level:2}],u={toc:p};function h(e){let{components:t,...i}=e;return(0,r.kt)("wrapper",(0,a.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"playwright + github actions + gh pages",src:n(9720).Z,width:"951",height:"511"})),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://playwright.dev/"},"Playwright")," is a modern cross-browser testing framework developed by microsoft itself.\n",(0,r.kt)("a",{parentName:"p",href:"https://docs.github.com/en/actions/"},"GitHub Actions")," is the out-of-the-box solution for anything related to CI/CD pipelines on GitHub.\nLast but not least ",(0,r.kt)("a",{parentName:"p",href:"https://pages.github.com/"},"GitHub Pages")," is a GitHub feature which allows to deploy static websites."),(0,r.kt)("p",null,"And all of this comes completely free for public repositories!"),(0,r.kt)("p",null,"In this blog post I will show you how to setup a basic a Playwright project, integrate it into GitHub Actions and finally deploy an HTML report of the test results to GitHub Pages."),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"The complete source code can be found in this repo: ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ysfaran/playwright-gh-actions-gh-pages"},"ysfaran/playwright-gh-actions-gh-pages"))),(0,r.kt)("p",null,"This post is ",(0,r.kt)("strong",{parentName:"p"},"not")," focusing on explaining all concepts of Playwright, but rather how to connect Playwright, GitHub Actions and GitHub Pages in a easy, non-cost way."),(0,r.kt)("h2",{id:"setup-playwright"},"Setup Playwright"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"For an up-to-date installation guide please always refer to ",(0,r.kt)("a",{parentName:"p",href:"https://playwright.dev/docs/intro"},"https://playwright.dev/docs/intro"),". At the point of writing this posts Playwright's latest version was ",(0,r.kt)("inlineCode",{parentName:"p"},"1.25.1"),".")),(0,r.kt)("p",null,"Fortunately Playwright makes it really easy to setup a new project using the CLI:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn create playwright\n")),(0,r.kt)("p",null,"This will start an interactive session. Make sure to at least enable GitHub Action workflow generation. Following is the configuration I used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"\u2714 Do you want to use TypeScript or JavaScript? \xb7 TypeScript\n\u2714 Where to put your end-to-end tests? \xb7 tests\n\u2714 Add a GitHub Actions workflow? (y/N) \xb7 true\n")),(0,r.kt)("h2",{id:"generate-html-report"},"Generate HTML Report"),(0,r.kt)("p",null,"One of the most important generated files is ",(0,r.kt)("inlineCode",{parentName:"p"},"playwright.config.ts"),", so let's have a look at it:"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"I simplified some of the generated files. For a full list of these changes see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ysfaran/playwright-gh-actions-gh-pages/commit/aab0b9c2f83fb57a31d38af74529062b5198ca45"},(0,r.kt)("inlineCode",{parentName:"a"},"aab0b9c2")),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'const config: PlaywrightTestConfig = {\n  testDir: "./tests",\n  // Run all tests within a file in parallel to speed up test execution\n  fullyParallel: true,\n  // Helpful for uncontrollable flaky tests, which are tests, occasionally failing for various reasons\n  retries: 3,\n  // Generates a HTML report to ./playwright-report/\n  reporter: "html",\n  use: {\n    // Tests will be run against this page\n    baseURL: "https://playwright.dev/",\n    // Collect trace when retrying the failed test. See https://playwright.dev/docs/trace-viewer\n    trace: "on-first-retry",\n  },\n  // Cross-browser testing setup\n  projects: [\n    {\n      name: "chromium",\n      use: {\n        ...devices["Desktop Chrome"],\n      },\n    },\n    {\n      name: "firefox",\n      use: {\n        ...devices["Desktop Firefox"],\n      },\n    },\n\n    {\n      name: "webkit",\n      use: {\n        ...devices["Desktop Safari"],\n      },\n    },\n  ],\n};\n')),(0,r.kt)("p",null,"Since the ",(0,r.kt)("inlineCode",{parentName:"p"},"html")," reporter is already enabled by default, there are no other adaption necessary.\nTo get a nice HTML report covering all test result cases (",(0,r.kt)("inlineCode",{parentName:"p"},"sucess"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"fail")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"flaky"),") following tests have been implemented:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'import { test, expect } from "@playwright/test";\n\ntest.beforeEach(({ page }) => page.goto("https://playwright.dev/"));\n\ntest("should succeed", async ({ page }) => {\n  await expect(page).toHaveTitle(/Playwright/);\n});\n\ntest("should fail", async ({ page }) => {\n  await expect(page).not.toHaveTitle(/Playwright/);\n});\n\ntest("should be flaky", async ({ page }) => {\n  if (Math.random() > 0.5) {\n    await expect(page).toHaveTitle(/Playwright/);\n  } else {\n    await expect(page).not.toHaveTitle(/Playwright/);\n  }\n});\n')),(0,r.kt)("p",null,"To run the tests execute:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npx playwright test\n")),(0,r.kt)("p",null,"After running all tests Playwright prints a summary of test restuls and publishes the HTML report to a server at a localhost address. Playwright also emits all sources for the HTML report to ",(0,r.kt)("inlineCode",{parentName:"p"},"playwright-report/"),"."),(0,r.kt)("h2",{id:"integrate-github-actions"},"Integrate GitHub Actions"),(0,r.kt)("p",null,"Luckily Playwright already generated a basic ",(0,r.kt)("inlineCode",{parentName:"p"},".github/workflows/playwright.yml")," during ",(0,r.kt)("a",{parentName:"p",href:"#setup-playwright"},"Setup Playwright")," to integrate Playwright tests into a GitHub Actions worklow:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},'name: Playwright Tests\non:\n  push:\n    branches: [main, master]\njobs:\n  test:\n    timeout-minutes: 60\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - uses: actions/setup-node@v2\n        with:\n          node-version: "14.x"\n      - name: Install dependencies\n        run: yarn\n      - name: Install Playwright Browsers\n        run: npx playwright install --with-deps\n      - name: Run Playwright tests\n        run: yarn playwright test\n      - uses: actions/upload-artifact@v2\n        if: always()\n        with:\n          name: playwright-report\n          path: playwright-report/\n          retention-days: 30\n')),(0,r.kt)("p",null,"Essentially the workflow is triggered on every ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," and executes the all tests, just like you would do it locally.\nIt's important to note that it also uploads the Playwright HTML report as workflow artifact.\nThis artifact will be available to download in the ",(0,r.kt)("inlineCode",{parentName:"p"},"Actions")," tab of your GitHub repository in each workflow run."),(0,r.kt)("p",null,"Please refer to the official Playwright docs on ",(0,r.kt)("a",{parentName:"p",href:"https://playwright.dev/docs/ci-intro#html-report"},"how to download and view HTML report files")," of a specific workflow run."),(0,r.kt)("h2",{id:"publish-html-report-to-github-pages"},"Publish HTML Report to GitHub Pages"),(0,r.kt)("p",null,"Being able to download, view and debug HTML reports generate by a CI/CD pipeline locally is already convenient, but there is an easier and faster way to check test results: automatically publish the HTML reports to GitHub Pages and view them directly in the browser."),(0,r.kt)("p",null,"Firstly a new orphan branch, which means the branch has no parent commit, for the GitHub Pages' static content needs to be created:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'# Create a new branch without any commit on it\ngit checkout --orphan gh-pages\n\n# Source files get autoamtically staged so remove them from git\ngit rm -rf .\n\n# Optional: Check if there are really no files in the git staging area anymore\ngit status\n\n# Create an initial, empty commit\ngit commit --allow-empty -m "setup empty branch for GitHub Pages"\n\n# Push the branch to make it available online\ngit push --set-upstream origin gh-pages\n')),(0,r.kt)("p",null,"Secondly the GitHub Pages feature needs to be enabled for your repo. Usually GitHub is enabling GitHub Pages automatically when you name a branch ",(0,r.kt)("inlineCode",{parentName:"p"},"gh-pages"),".\nIf it doesn't, make sure to enable GitHub Pages manually in your repository settings:"),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Enable GitHub Pages",src:n(1326).Z,width:"2890",height:"1636"})),(0,r.kt)("p",null,"Any change that is pushed to ",(0,r.kt)("inlineCode",{parentName:"p"},"gh-pages")," will now automatically update the GitHub Pages website, which is publicly available at ",(0,r.kt)("inlineCode",{parentName:"p"},"https://<user>.github.io/<repo>/"),".\nBecause there is no real commit on the ",(0,r.kt)("inlineCode",{parentName:"p"},"gh-pages")," branch yet a 404 error page will be shown."),(0,r.kt)("p",null,"So the next logical step is to add a new job to the GitHub Actions workflow in order to push the HTML reports to ",(0,r.kt)("inlineCode",{parentName:"p"},"gh-pages")," branch:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},'publish_report:\n  name: Publish HTML Report\n  # using always() is not ideal here, because it would also run if the workflow was cancelled\n  if: "success() || needs.test.result == \'failure\'"\n  needs: [test]\n  runs-on: ubuntu-latest\n  continue-on-error: true\n  env:\n    # Unique URL path for each workflow run attempt\n    HTML_REPORT_URL_PATH: reports/${{ github.ref_name }}/${{ github.run_id }}/${{ github.run_attempt }}\n  steps:\n    - name: Checkout GitHub Pages Branch\n      uses: actions/checkout@v2\n      with:\n        ref: gh-pages\n    - name: Set Git User\n      # see: https://github.com/actions/checkout/issues/13#issuecomment-724415212\n      run: |\n        git config --global user.name "github-actions[bot]"\n        git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"\n    - name: Download zipped HTML report\n      uses: actions/download-artifact@v2\n      with:\n        name: playwright-report\n        path: ${{ env.HTML_REPORT_URL_PATH }}\n    - name: Push HTML Report\n      timeout-minutes: 3\n      # commit report, then try push-rebase-loop until it\'s able to merge the HTML report to the gh-pages branch\n      # this is necessary when this job is running at least twice at the same time (e.g. through two pushes at the same time)\n      run: |\n        git add .\n        git commit -m "workflow: add HTML report for run-id ${{ github.run_id }} (attempt:  ${{ github.run_attempt }})"\n\n        while true; do\n          git pull --rebase\n          if [ $? -ne 0 ]; then\n            echo "Failed to rebase. Please review manually."\n            exit 1\n          fi\n\n          git push\n          if [ $? -eq 0 ]; then\n            echo "Successfully pushed HTML report to repo."\n            exit 0\n          fi\n        done\n    - name: Output Report URL as Worfklow Annotation\n      run: |\n        FULL_HTML_REPORT_URL=https://ysfaran.github.io/playwright-gh-actions-gh-pages/$HTML_REPORT_URL_PATH\n\n        echo "::notice title=\ud83d\udccb Published Playwright Test Report::$FULL_HTML_REPORT_URL"\n')),(0,r.kt)("p",null,"Basically this job commits the HTML report files to the ",(0,r.kt)("inlineCode",{parentName:"p"},"gh-pages")," branch, which will then automatically redploy the website."),(0,r.kt)("p",null,"It does so by specifying a new unique path for each test result:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yml"},"HTML_REPORT_URL_PATH: reports/${{ github.ref_name }}/${{ github.run_id }}/${{ github.run_attempt }}\n")),(0,r.kt)("p",null,"The job then tries to push these changes and rebases if necessary until a push was succssful.\nRebasing is safe here, because - as already mentioned - each workflow run gets its own uniquie path, so there can't be any file conflicts ever."),(0,r.kt)("p",null,"Last but not least the publicly available URL is printed as GitHub Worfklow Annotation:"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"It might take some while for GitHub Pages to update its content after a new push, so the printed URL will point to a 404 page initially.\nIn the ",(0,r.kt)("inlineCode",{parentName:"p"},"Actions")," tab of your repo you can check ",(0,r.kt)("inlineCode",{parentName:"p"},"pages-build-deployment")," workflow runs, which is automatically triggered for GitHub Pages, to see if the GitHub Pages deployment was successful.")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"URL as GitHub Worfklow Annotation",src:n(7403).Z,width:"3560",height:"1664"})),(0,r.kt)("h2",{id:"add-multi-branch-support"},"Add Multi-Branch Support"),(0,r.kt)("p",null,"Only in rare cases you work on a single branch. Also the pipeline is currently not integrated in any pull request process, meaning that there are no restriction to push or even force push to your ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),"/",(0,r.kt)("inlineCode",{parentName:"p"},"master"),".\nIts time to change that!"),(0,r.kt)("p",null,"First of all we need to enable branch protections rules for the default branch:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Go to the settings of your repo"),(0,r.kt)("li",{parentName:"ol"},"Select ",(0,r.kt)("inlineCode",{parentName:"li"},"Branches")," under ",(0,r.kt)("inlineCode",{parentName:"li"},"Code and automation")," in the menu"),(0,r.kt)("li",{parentName:"ol"},"Hit the ",(0,r.kt)("inlineCode",{parentName:"li"},"Add branch protection rule")," button"),(0,r.kt)("li",{parentName:"ol"},"Add your default branchs name for ",(0,r.kt)("inlineCode",{parentName:"li"},"Branch name pattern")),(0,r.kt)("li",{parentName:"ol"},"Configure your branch protecting rules as desired, most importantly being:")),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Branch protections rules",src:n(3490).Z,width:"1554",height:"1424"})),(0,r.kt)("p",null,"Note that I only put ",(0,r.kt)("inlineCode",{parentName:"p"},"Test")," under ",(0,r.kt)("inlineCode",{parentName:"p"},"Status checks that are required.")," because you should still be allowed to merge to ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," branch if some HTML report couldn't be published.\nA green ",(0,r.kt)("inlineCode",{parentName:"p"},"Test")," job for a branch represents a valid state anyway in this case."),(0,r.kt)("p",null,"Secondly the workflow needs to be adapted:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-diff"},"on:\n  push:\n-    branches: [ main, master ]\n-  pull_request:\n-    branches: [ main, master ]\n+    branches-ignore: [ main, gh-pages ]\n")),(0,r.kt)("p",null,"So the workflow is triggered after each push on every branch except ",(0,r.kt)("inlineCode",{parentName:"p"},"main")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"gh-pages"),".\nI purposely removed ",(0,r.kt)("inlineCode",{parentName:"p"},"pull_request")," here, because it's really hard (at this point in time) to make ",(0,r.kt)("inlineCode",{parentName:"p"},"push")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"pull_requests")," work together with GitHub Actions.\nFeel free to check my answer on ",(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/71158335/6489012"},"StackOverflow answer")," regarding this topic."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"If you want to work with ",(0,r.kt)("inlineCode",{parentName:"p"},"pull_request")," every occurence of ",(0,r.kt)("inlineCode",{parentName:"p"},"${{ github.ref_name }}")," should be replaces with ",(0,r.kt)("inlineCode",{parentName:"p"},"${{ github.head_ref || github.ref_name }}"),".\nCheck the related StackOverflow answer for details: ",(0,r.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/71158878/6489012"},"https://stackoverflow.com/a/71158878/6489012"),".")),(0,r.kt)("p",null,"I also highly recommend to enable ",(0,r.kt)("a",{parentName:"p",href:"https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions#concurrency"},"concurrency groups")," in your workflow file to make sure only one workflow is running at the same time for each branch:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"concurrency:\n  group: ${{ github.ref_name }}\n  # optional\n  cancel-in-progress: true\n")),(0,r.kt)("h2",{id:"delete-reports-from-github-pages"},"Delete Reports from GitHub Pages"),(0,r.kt)("p",null,"After a branch was successfully merged it makes sense to delete all corresponding HTML reports from GitHub Pages. This requires the implementation of a new workflow file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'name: Delete\n\non:\n  delete:\n    branches-ignore: [main, gh-pages]\n\n# ensures that currently running Playwright workflow of deleted branch gets cancelled\nconcurrency:\n  group: ${{ github.event.ref }}\n  cancel-in-progress: true\n\njobs:\n  delete_reports:\n    name: Delete Reports\n    runs-on: ubuntu-latest\n    env:\n      # Contains all reports for deleted branch\n      BRANCH_REPORTS_DIR: reports/${{ github.event.ref }}\n    steps:\n      - name: Checkout GitHub Pages Branch\n        uses: actions/checkout@v2\n        with:\n          ref: gh-pages\n      - name: Set Git User\n        # see: https://github.com/actions/checkout/issues/13#issuecomment-724415212\n        run: |\n          git config --global user.name "github-actions[bot]"\n          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"\n      - name: Check for workflow reports\n        run: |\n          if [ -z "$(ls -A $BRANCH_REPORTS_DIR)" ]; then\n            echo "BRANCH_REPORTS_EXIST="false"" >> $GITHUB_ENV\n          else\n            echo "BRANCH_REPORTS_EXIST="true"" >> $GITHUB_ENV\n          fi\n      - name: Delete reports from repo for branch\n        if: ${{ env.BRANCH_REPORTS_EXIST == \'true\' }}\n        timeout-minutes: 3\n        run: |\n          cd $BRANCH_REPORTS_DIR/..\n\n          rm -rf ${{ github.event.ref }}\n          git add .\n          git commit -m "workflow: remove all reports for branch ${{ github.event.ref }}"\n\n          while true; do\n            git pull --rebase\n            if [ $? -ne 0 ]; then\n              echo "Failed to rebase. Please review manually."\n              exit 1\n            fi\n\n            git push\n            if [ $? -eq 0 ]; then\n              echo "Successfully pushed HTML reports to repo."\n              exit 0\n            fi\n          done\n')),(0,r.kt)("p",null,"The job of this workflow is pretty similiar to the one publishing the HTML report. This time it's just the other way around: ",(0,r.kt)("inlineCode",{parentName:"p"},"gh-pages")," branch is checked out and the folder ",(0,r.kt)("inlineCode",{parentName:"p"},"reports/<branch-name>")," is deleted.\nThen the same push-rebase loop is initated to trigger a GitHub Pages deployment."),(0,r.kt)("p",null,"Important to note here is the following part:"),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"This time the name of the (deleted) branch is neither retreived by ",(0,r.kt)("inlineCode",{parentName:"p"},"github.head_ref")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"github.ref_name"),", but ",(0,r.kt)("inlineCode",{parentName:"p"},"github.event.ref"),".\nIn case the workflow was triggered by a ",(0,r.kt)("inlineCode",{parentName:"p"},"delete")," the value of ",(0,r.kt)("inlineCode",{parentName:"p"},"github.ref_name")," will be the one of the default branch, here ",(0,r.kt)("inlineCode",{parentName:"p"},"main"),".")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"concurrency:\n  group: ${{ github.event.ref }}\n  cancel-in-progress: true\n")),(0,r.kt)("p",null,"This statement makes sure that any running workflow within the same concurrency group will be cancelled.\nIn our case this means if tests for a deleted branch are still running, they will be cancelled."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"We created a Playwright project from scratch, integrated tests in GitHub Actions, deployed test results to GitHub Pages and finally established branch protections rules with a simple but important pull request strategy.\nAll of this, without any costs."),(0,r.kt)("p",null,"All in all it's all about automation and process optimization. Keeping a team busy with daunting manual tasks can decrease effincy and motivation quite a bit.\nThis can go from manual deployment plans to smaller aspects like hard to debug test results. In the long run saving some minutes of daily, manual work can have a huge impact."),(0,r.kt)("p",null,"Questions and feedback are always welcome. \ud83d\ude42"))}h.isMDXComponent=!0},3490:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/branch-protection-rules-91f9f3a4838eb237b4197234bd8cadfb.png"},1326:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/gh-pages-settings-69a307d9ba193a63a261c0a096e11c0c.png"},9720:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/playwright-gh-actions-gh-pages-910a8b103ecdf8af512f6172560b0a8c.png"},7403:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/workflow-annotation-e81a84df7c3eb911708a2bfbbe1cb215.png"}}]);